{
    "__type__": "Deck",
    "children": [],
    "crowdanki_uuid": "f8c5beda-aa93-11ef-bec0-d9aa25b9a078",
    "deck_config_uuid": "3ca4f968-a9d6-11ef-974d-f92c0362d330",
    "deck_configurations": [
        {
            "__type__": "DeckConfig",
            "answerAction": 0,
            "autoplay": true,
            "buryInterdayLearning": false,
            "crowdanki_uuid": "3ca4f968-a9d6-11ef-974d-f92c0362d330",
            "desiredRetention": 0.9,
            "dyn": false,
            "easyDaysPercentages": [
                1.0,
                1.0,
                1.0,
                1.0,
                1.0,
                1.0,
                1.0
            ],
            "fsrsParams5": [],
            "fsrsWeights": [],
            "ignoreRevlogsBeforeDate": "",
            "interdayLearningMix": 0,
            "lapse": {
                "delays": [
                    10.0
                ],
                "leechAction": 1,
                "leechFails": 8,
                "minInt": 1,
                "mult": 0.0
            },
            "maxTaken": 60,
            "name": "Default",
            "new": {
                "bury": false,
                "delays": [
                    1.0,
                    10.0
                ],
                "initialFactor": 2500,
                "ints": [
                    1,
                    4,
                    0
                ],
                "order": 1,
                "perDay": 20
            },
            "newGatherPriority": 0,
            "newMix": 0,
            "newPerDayMinimum": 0,
            "newSortOrder": 0,
            "questionAction": 0,
            "replayq": true,
            "rev": {
                "bury": false,
                "ease4": 1.3,
                "hardFactor": 1.2,
                "ivlFct": 1.0,
                "maxIvl": 36500,
                "perDay": 200
            },
            "reviewOrder": 0,
            "secondsToShowAnswer": 0.0,
            "secondsToShowQuestion": 0.0,
            "sm2Retention": 0.9,
            "stopTimerOnAnswer": false,
            "timer": 0,
            "waitForAudio": true,
            "weightSearch": ""
        }
    ],
    "desc": "",
    "dyn": 0,
    "extendNew": 0,
    "extendRev": 0,
    "media_files": [
        "Screenshot 2025-03-31 at 22.56.33.png"
    ],
    "name": "computer science",
    "newLimit": null,
    "newLimitToday": {
        "limit": 40,
        "today": 210
    },
    "note_models": [
        {
            "__type__": "NoteModel",
            "crowdanki_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "css": ".card {\n    font-family: arial;\n    font-size: 20px;\n    text-align: center;\n    color: black;\n    background-color: white;\n}\n",
            "flds": [
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "id": -3568197255527884728,
                    "name": "Front",
                    "ord": 0,
                    "plainText": false,
                    "preventDeletion": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": false,
                    "tag": null
                },
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "id": -8792581457391807817,
                    "name": "Back",
                    "ord": 1,
                    "plainText": false,
                    "preventDeletion": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": false,
                    "tag": null
                }
            ],
            "latexPost": "\\end{document}",
            "latexPre": "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n",
            "latexsvg": false,
            "name": "Basic",
            "originalStockKind": 1,
            "req": [
                [
                    0,
                    "any",
                    [
                        0
                    ]
                ]
            ],
            "sortf": 0,
            "tags": [],
            "tmpls": [
                {
                    "afmt": "{{FrontSide}}\n\n<hr id=answer>\n\n{{Back}}",
                    "bafmt": "",
                    "bfont": "",
                    "bqfmt": "",
                    "bsize": 0,
                    "did": null,
                    "id": -7066904010460991323,
                    "name": "Card 1",
                    "ord": 0,
                    "qfmt": "{{Front}}"
                }
            ],
            "type": 0
        }
    ],
    "notes": [
        {
            "__type__": "Note",
            "fields": [
                "i-ème bit",
                "\\[b_i = (n/2^i)\\%2\\]"
            ],
            "guid": "mkUt-?:tAl",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": []
        },
        {
            "__type__": "Note",
            "fields": [
                "nombres de bits",
                "\\[log_2(n) + 1\\]"
            ],
            "guid": "F:AM.X$$9C",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": []
        },
        {
            "__type__": "Note",
            "fields": [
                "méthodes structures de données",
                "constructeurs<br>accesseurs<br>transformateurs"
            ],
            "guid": "uX?=ks)$f8",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "structures::de::données"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "canaux de communication",
                "stdout<br>stderr<br>stdin"
            ],
            "guid": "Q!9n1Fs._6",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "structures::de::données"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "comment vider le channel (file)",
                "fflush(stdchan)"
            ],
            "guid": "l,~;k`D>R(",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "structures::de::données"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "rediréction de canaux",
                "&lt;: redirige stdin<br>&gt;: redirige stdout<br>&gt;&gt;: stdout + append<br>grep: filtrer<br>sort: trier<br>|: stdout d'une commande est le stdin de la suivante (un genre de tuyau)"
            ],
            "guid": "=q`37RWQ{",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "structures::de::données"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "processus (unix)",
                "&amp; chainage parallèle<br>&amp;&amp; chaînage séquentiel"
            ],
            "guid": "HoAeHl<~->",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "structures::de::données"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "commandes de compilation (C)",
                "gcc -o nom ./main.c<br>gcc -c lib.c<br>gcc -o nom lib.o main.o"
            ],
            "guid": "cD%AV0.Sq-",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "structures::de::données"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "commandes de compilation (Ocaml)",
                "ocamlc -o nom ./main.ml<br>ocamlc&nbsp;-c lib.ml<br>ocamlc&nbsp;-o nom lib.cmo main.cmo"
            ],
            "guid": "RafqW;Q$/q",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "structures::de::données"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "liste abstraite",
                "liste python<br>on peut ajouter, enlever le dernier élément, remplacer en O(1)<br>on utilise les tableaux dynamiques"
            ],
            "guid": "M|VAUKLB}W",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "structures::de::données"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "complexité amortie",
                "étudier la complexité pire cas d'une suite d'opérations<br>\\[C^{am}_{method}(n) = \\lim_{m\\to+\\infty}{\\frac{1}{m}}\\sum_{i=1}^m{C_{i,n}}\\]<br>"
            ],
            "guid": "oHj!Ljt7k/",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "structures::de::données"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "démontrer que la complexité amortie de append est en O(1)",
                "pire cas: len = memlen<br>après 1 opération: taille =&nbsp;\\(2n\\)<br>après 1 + n opérations: taille =&nbsp;\\(4n\\)<br>après m opérations: taille =&nbsp;\\(2^dn\\)<br>On a&nbsp;\\(2^{d-1}n &lt; n + m &lt; 2^dn\\)<br>\\[\\sum_{i=1}^m{C_i} = 1\\times(m-d) + \\sum_{j=0}^{d-1}{2^in} = (m - d - n) + 2^dn = A\\]\\[(m-d-n) + (m+n) &lt; A &lt; (m-d-n)+2(m+n)\\]<br>Donc:<br>\\[2n - d &lt; A &lt; 3m - d+n\\]Dond:<br>\\[\\frac{2m-d}{m} \\le \\frac{A}{m} \\le \\frac{3m+n}{m}\\]Donc&nbsp;\\(C_{op}^{am} \\in [\\![ 2; 3 ]\\!] = \\mathcal{O}(1)\\)&nbsp;<br>"
            ],
            "guid": "J6_3%D[ei,",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "structures::de::données"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "piles",
                "tout en O(1)<br>en C: listes chaînes<br>en Ocaml: listes"
            ],
            "guid": "zv(eyI6#Xz",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "structures::de::données"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Files",
                "via tableaux dynamiques<br>via 2 piles<br>via listes chaînées"
            ],
            "guid": "QiVESk{@!Q",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "structures::de::données"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "dictionnaires",
                "listes ou tableaux associatifs<br>ABR<br>tables de hashage"
            ],
            "guid": "cm^;TQ-Zc=",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "structures::de::données"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "vocabulaire arbres",
                "racine<br>sous-arbre<br>noeud<br>arrête<br>feuilles -&gt; forment frontière<br>chemin<br>étiquette"
            ],
            "guid": "m,r,Q[,BT1",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "structures::de::données"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "branche arbre",
                "chemin de la racine jusqu'à une feuille"
            ],
            "guid": "c^Qc.]-<FU",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "structures::de::données"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "profondeur d'un noeud (arbre)",
                "longueur de l'unique chemin de la racine jusqu'au noeud<br>la racine est de profondeur 0"
            ],
            "guid": "KX`0wVblgr",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "structures::de::données"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "hauteur (arbre)",
                "la profondeur maximale d'un noeud de l'arbre"
            ],
            "guid": "s-ziWdYV]L",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "structures::de::données"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "arité d'un arbre",
                "arité&nbsp; maximale d'un noeud"
            ],
            "guid": "G/0;U(SG/0",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "structures::de::données"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "définition formelle arbre",
                "un arbre est un ensemble d'adresses clos par préfixe<br><br>addresse: liste d'entiers représentant le chemin jusuqu'à un noeud"
            ],
            "guid": "hWFa=!F8`T",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "structures::de::données"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "définition récursive arbre",
                "\\[\\begin{align}\n&amp; E_0 = \\{F\\}\\\\\n&amp; E_{i+1} = E_i \\cup \\{ N(g,d) \\mid g \\in E_i, d \\in E_i \\}\n\\end{align}\\]suite croissante d'ensembles pour l'inclusion<br>\\[E = \\bigcup_{n\\in\\mathbb{N}}{E_n}\\]<br>"
            ],
            "guid": "KdO03QIra<",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "structures::de::données"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "définition récursive hauteur",
                "\\(E_{i+1}\\setminus E_i\\)&nbsp;contient tous les arbres de hauteur i+1<br>\\[h(A) = \\min\\{ i \\mid A \\in E_i \\}\\]&nbsp;<br>"
            ],
            "guid": "M>)khScRo6",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "structures::de::données"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "définition arbre binaire",
                "arbre binaire T tel que pour tout noeud Node(x,g,d) de l'arbre, on ait:&nbsp;<br>les élements de g sont inférieurs ou égaux à x et ceux de d strictement plus grands"
            ],
            "guid": "O@rBjePYHy",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "arbres::binaires::de::recherche"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "définition inductive ABR",
                "un abre binaire est un [a;b]-ABR si:<br>soit T = Nil<br>soit T = Node(r,g,d) et g est un [a;r]-ABR et d un ]r;d]-ABR et&nbsp;\\(r \\in [a;b]\\)<br><br>un abre binaire est un ABR si c'est un&nbsp;\\([]-\\infty;+\\infty[]-ABR\\)&nbsp;ou&nbsp;\\(\\exists a,b\\)&nbsp;tq T est un&nbsp;\\([a;b]-ABR\\)"
            ],
            "guid": "w|PY:En`w`",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "arbres::binaires::de::recherche"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "complexité recherche ABR",
                "O(h(t)) = O(log(t))"
            ],
            "guid": "MzB14ftx4+",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "arbres::binaires::de::recherche"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "supression dans un ABR",
                "on recherche x dans T<br>lorque trouvé<br>- si le noeud contant x à 0/1 enfants -&gt; son enfant prend sa place<br>- sinon (g,d)-&gt; on place max(g) dans le noeud qui contient x, on supprime max(g) dans g"
            ],
            "guid": "DGN/wk4k(d",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "arbres::binaires::de::recherche"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "proposition prédecesseur",
                "T un ABR sans doublons, et&nbsp;\\(x \\ne min(T)\\). Soit&nbsp;\\(Node(x,g_x,d_x)\\)&nbsp;le sous-arbre de T dont la racine est x.<br><br>1) Si&nbsp;\\(g_x \\ne Nil\\),&nbsp;\\(pred_T(x) = max(g)\\)<br>2) Sinon, l'étiquette d'un ancêtre de x dans T, le noeud a le moins profond de T tel que le chemin de a à x soit de descendre une fois à droite et toujours à gauche."
            ],
            "guid": "P{p%&ztw,n",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "arbres::binaires::de::recherche"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "&nbsp;rotations ABR",
                "<img src=\"Screenshot 2025-03-31 at 22.56.33.png\">"
            ],
            "guid": "e4I@?^a+bY",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "arbres::binaires::de::recherche"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "définition AVL",
                "un ABR est un AVL si pour tout sous-arbre de la forme Node(x,g,d)&nbsp;\\(|h(g) - h(d)| \\le 1\\)"
            ],
            "guid": "Br7`YRf!HO",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "arbres::binaires::de::recherche"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "complexité tri ABR",
                "\\[O(nlog(n))\\]car chaque insertion coûte&nbsp;\\(O(log(n))\\)&nbsp;et on a&nbsp;\\(n\\)&nbsp;insertions<br>"
            ],
            "guid": "p<~{J!is|%",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "arbres::binaires::de::recherche"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "recap complexité espace",
                "on mesure le pic de consommation mémoire<br>on ne compte que l'espace de travail intermédiaire (ni l'entrée, ni la sortie)"
            ],
            "guid": "Gm_Z;.MgPk",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "complexité::espace"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "conso espace pour un programme récursif",
                "proportionnel au nombre d'appels"
            ],
            "guid": "eS>@g^$NtX",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "complexité::espace"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "définition mathématique graphe",
                "\\[G = (V,E)\\]où V est un ensemble fini de sommets (vertex, vertices) et&nbsp;\\(E \\subset V \\times V\\)&nbsp;est l'ensemble des arêtes (edge)<br>"
            ],
            "guid": "GRa7o44OO}",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "boucle",
                "arête de la forme (u,u)"
            ],
            "guid": "4k^`8]9p>",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "définition graphe non orienté",
                "\\[\\forall u,v \\in V, (u,v) \\in E \\implies (v,u) \\in E\\]<br>"
            ],
            "guid": "igSyGJ&f{)",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "définition voisin",
                "\\[(u,v) \\in E\\]v est voisin de u (successeur)<br>u prédecesseur de v"
            ],
            "guid": "d3x!=z|C#q",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "degré sortant / degré entrant",
                "\\[d_+(u) = |\\{ v \\in V, (u,v) \\in E \\}|\\]\\[d_-(u) = |\\{ v \\in V, (v,u) \\in E \\}|\\]<br>"
            ],
            "guid": "DlWWoP.e>.",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "identité d'Euler",
                "\\[d_+(u) \\le |E|\\]\\[d_-(u) \\le |E|\\]\\[\\sum_{u\\in V}{d_+(u)} = \\sum_{u\\in V}{d_-(u)} = |E|\\]<br>"
            ],
            "guid": "jNx8.%rNI$",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "chemin",
                "suite finie de sommets<br>u0 est l'origine (source) et u_k son arrivée"
            ],
            "guid": "P)[}QNaMrP",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "définition accessible",
                "t accessible depuis s s'il existe une chemin d'origine s et d'arrivée t"
            ],
            "guid": "sS4Q])0int",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "chemin simple",
                "suite ne contient pas deux fois le même sommet"
            ],
            "guid": "Q#Ag;-f;s!",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "cycle",
                "si u0 = uk"
            ],
            "guid": "gX_HDf~.M@",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "graphe orienté acyclique",
                "si il ne contient pas de cycle"
            ],
            "guid": "bYK4yQYxCz",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "graphe non orienté acyclique",
                "si il ne contient pas de cycle simple de longuer supérieure ou égale à 3"
            ],
            "guid": "hDpytFN]hp",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "propriété graphe acyclique",
                "G est acyclique ssi&nbsp;\\(\\forall u,v \\in V\\)&nbsp;il existe au plus un chemin simple de u à v"
            ],
            "guid": "y5/n;&1LiZ",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "&nbsp;sous-graphe",
                "\\[G' = (V',E')\\]\\[V' \\subset V\\]\\[E' = E\\cap(V'\\times V')\\]<br>"
            ],
            "guid": "w{%TjM/FQC",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "connexité graphe non-orienté",
                "\\[\\forall s, t\\in V\\]t est accessible depuis s<br>"
            ],
            "guid": "q(qG=M=.BR",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "forte connexité graphe orienté",
                "pour tout sommets s,t: t est accessible depuis s"
            ],
            "guid": "e6Mh~;drs&",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "graphe faiblement connexe",
                "lorsqu'un graphe orienté est connexe vu comme un graphe non-orienté"
            ],
            "guid": "c6$~>bT]a;",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "composante connexe (graphe non orienté)",
                "sous-graphe maximal connexe"
            ],
            "guid": "FG96hJq#UJ",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "composante connexe de u",
                "l'unique composante connexe qui contient u"
            ],
            "guid": "EB0iaw/)5L",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "composante fortement connexe",
                "sous-graphe maximal fortement connexe"
            ],
            "guid": "w%^l7N$*?9",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "définition arbre comme graphe",
                "graphe non-orienté connexe acyclique"
            ],
            "guid": "f7&H^Q-bQC",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "forêt",
                "graphe dont chaque composante connexe est un arbre (graphe non-orienté acyclique)"
            ],
            "guid": "I/z..qq{^G",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "graphe biparti",
                "graphe pour lequel on peut partitionner V en deux ensembles disjoints&nbsp;\\(V_1\\)&nbsp;et&nbsp;\\(V_2\\)&nbsp;non vides tels que&nbsp;<br>\\[i \\in \\{0;1\\}, \\forall u,v \\in V_i, (u,v) \\notin E\\]<br>"
            ],
            "guid": "cs%%Nj+y:T",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "inégalité graphes",
                "\\[n = |V|, m = |E|\\]\\[m \\le n^2\\]<br>"
            ],
            "guid": "vHN{NIa)Zb",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "graphes"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "définition Tas",
                "arbre binaire presque complet: tous les étages sont pleins sauf eventuellement le dernier, et au dernier étage les noeuds sont le plus à gauche possible"
            ],
            "guid": "AjN=Z4>kHN",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "tas::binaire"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Tas-Max",
                "tas étiqueté tel que l'étiquette de chaque noeud est supérieur à celles de ses enfants (donc max = racine)"
            ],
            "guid": "vUc32h7hl2",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "tas::binaire"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "implémentation Tas",
                "tableau T de longueur N<br>racine T[0]<br>enfants de i T[2i+1] T[2i+2]"
            ],
            "guid": "A5#3`$,8<R",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "tas::binaire"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "percolate up/down",
                "# T: tas; i : noeud;<br># On suppose que l’étiquette de i a été modifiée pour une valeur supérieure<br>def percolate_up(T, i):<br>&nbsp;&nbsp;&nbsp; soit p le parent de i<br>&nbsp;&nbsp;&nbsp; si i n’est pas la racine et l’étiquette de i &gt; étiquette de p :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; échanger dans T l’étiquette de i et celle de p<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; percolate_up(T, parent(i))<br><br># On suppose que l’étiquette de i a été modifiée pour une valeur inférieure<br>def percolate_down(T, i):<br>&nbsp;&nbsp;&nbsp; soit m le noeud d’étiquette maximale entre i, son éventuel fils gauche<br>&nbsp;&nbsp;&nbsp; et son éventuel fils droit<br>&nbsp;&nbsp;&nbsp; échanger dans T l’étiquette de i et celle de m<br>&nbsp;&nbsp;&nbsp; si m est différent de i :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; percolate_down(T, m)"
            ],
            "guid": "AqLW`-l8Ul",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "tas::binaire"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "complexité percolate",
                "\\[O(logn)\\]<br>"
            ],
            "guid": "J^6hr`~,YZ",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "tas::binaire"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "définition problème de recherche",
                "E un ensemble fini de candidats.&nbsp;<br><br>Problème de recherche consiste à chercher un élément de E qui vérifie une certaine propriété, élément appelé solution."
            ],
            "guid": "BlqJfWPH=7",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "algorithmique"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "définition problème d'optimisation",
                "chercher une solution optimale parmis S, l'ensemble des solutions. L'optimalité se fait selon une certain métrique qui dépend du problème."
            ],
            "guid": "f^>?z(1kU!",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "algorithmique"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "différentes énumérations pour un algo en force brute",
                "<ul><li>\\(E = [a;b]\\)<br></li><li>\\(E = A \\times B\\)</li><li>\\(E = \\mathcal{P}([0;n-1])\\)</li><li>\\(E = S_n\\)&nbsp;(ensemble des permutations)</li><li>\\(E = A^B\\)<br></li></ul>"
            ],
            "guid": "rv+crdIbV]",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "algorithmique"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "définition backtracking",
                "L'espace de recherche est un arbre:<br>- chaque noeud interne est un candidat partiel<br>- chaque feuille est un véritable candidat<br>- tous les éléments de E apparaissent bien sur au moins une feuille"
            ],
            "guid": "LU@5?1paQL",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "algorithmique::backtracking"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "squelette backtracking",
                "code(données):<br>&nbsp; &nbsp; &nbsp; def des obj mutables: candidats partiels<br>&nbsp; &nbsp; &nbsp; let rec aux candidat partiel =&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;candidat partiel = solution ? -&gt; arrêter tout<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;candidat partiel impossible ? -&gt; répondre faux<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pour chaque choix possible:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;modifie le candidat partiel pour réfléter ce choix<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;aux candidat partiel<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;effacer ses traces"
            ],
            "guid": "PVd]-r%$mo",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "algorithmique::backtracking"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "définition problème",
                "description d'une entrée et d'une question"
            ],
            "guid": "mB^#5y$09#",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "algorithmique::backtracking"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "définition instance d'un problème",
                "une entrée donnée à un problème"
            ],
            "guid": "IXs0Lr/K4=",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "algorithmique::backtracking"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "défintion algorithme glouton",
                "Pour résoudre un problème de recherche / optimisation, l'algorithme glouton effectue une série de <b><u>choix sans jamais le remettre en question</u></b>. Il optimise <b><u>localement</u></b> en suivant une <b><u>heuristique</u></b> (une <b><u>approximation</u></b> <u><b>imprécise</b></u> de la structure mais rapide à évaluer)."
            ],
            "guid": "6v}[+hnEH",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "algorithmique::gloutons"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "mémoisation",
                "mémoriser les résultats des sous-problèmes au cas où ils apparaissent plusieurs fois."
            ],
            "guid": "I?1GOC+)CF",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "algorithmique::programmation::dynamique"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "sous structure optimale",
                "lorsque les solutions des sous-problèmes une fois combinées donnent la solution du problème de départ."
            ],
            "guid": "CE6WAL63)r",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "algorithmique::programmation::dynamique"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "principe d'optimalité de Bellman",
                "Une chemin optimal est formé de sous-chemins optimaux: Si (C) est un chemin optimal allant de A à B et si C appartient à (C) alors les sous-chemins de (C) allant de A à C et de C à B sont optimaux.<br><br>Se démontre par l'absurde"
            ],
            "guid": "f$fwL1F1?N",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "algorithmique::programmation::dynamique"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "squelette version ascendante",
                "def ascendate(pb):<br>&nbsp; &nbsp; &nbsp; T =&nbsp; []<br>&nbsp; &nbsp; &nbsp; for i in range(...):<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[i][0] = ....<br>&nbsp; &nbsp; &nbsp; for i in range (N+1):<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for j in range(1,.....):<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T[i][j] = equation de récurrence<br>&nbsp; &nbsp; &nbsp; &nbsp;return T[...][...]"
            ],
            "guid": "N`,M$0d)%E",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "algorithmique::programmation::dynamique"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "squelette version descendante",
                "def desc(pb):<br>&nbsp; &nbsp; &nbsp; T = ....<br>&nbsp; &nbsp; &nbsp; T[base] &lt;- ...<br>&nbsp; &nbsp; &nbsp; def aux(ss_pb):<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ss_pb pas dans T<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T[ss_pb] = eq de rec<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return T[ss_pb]<br>&nbsp; &nbsp; &nbsp; return aux(pb)"
            ],
            "guid": "hx}}qdGsL:",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "algorithmique::programmation::dynamique"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Méthodes pour reconstruire la solution",
                "1) On remonte la table comme sur le schéma<br>2) On créé une table opti de même taille que T et on la remplit en parallèle de T<br>3) Garder les solutions explicites dans la table"
            ],
            "guid": "K~?0>w6(Hs",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "algorithmique::programmation::dynamique"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "étapes diviser pour régner",
                "0) Cas de base<br>1) Diviser<br>2) Régner<br>3) Combiner"
            ],
            "guid": "o$;zRfi[Ay",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "algorithmique::diviser_pour_régner"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "formule générale complexité diviser pour régner",
                "\\[T(n) = aT(n/b) + \\mathcal{O}(f(n) + g(n))\\]<br>"
            ],
            "guid": "vGvWSg|s8j",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "algorithmique::diviser_pour_régner"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "méthodes de résolution complexité diviser pour régner",
                "- récurrence<br>- à l'intuition<br>- méthode formelle"
            ],
            "guid": "z)M0Nl>!&u",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "algorithmique::diviser_pour_régner"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "théorème maître",
                "\\[T(n) = aT(n/b) + f(n)\\]<u><b>3 cas:</b></u><br><ol><li>Si&nbsp;\\(f(n) = \\mathcal{O}(n^{c-\\epsilon})\\)&nbsp;pour un entier&nbsp;\\(\\epsilon &gt; 0\\)&nbsp;alors&nbsp;\\(T(n) = \\Theta(n^c)\\)</li><li>Si&nbsp;\\(f(n) = \\Omega(n^{c+\\epsilon})\\)&nbsp;+ hypothèse alors&nbsp;\\(T(n) = \\Theta(f(n))\\)</li><li>Si&nbsp;\\(f(n) = \\Theta(n^c \\log^kn)\\)&nbsp;pour un certain k alors&nbsp;\\(T(n) = \\Theta(n^c\\log^{k+1}n)\\)</li></ol>"
            ],
            "guid": "dSpNwLpH8V",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "algorithmique::diviser_pour_régner"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "astuce de preuve complexité diviser pour régner",
                "on pose la suite&nbsp;\\(v_k = \\frac{T(b^k)}{a^k}\\)"
            ],
            "guid": "i#AxhIpJz_",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "algorithmique::diviser_pour_régner"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "valuation du et, ou, implique, équivalent",
                "-&nbsp;\\(v(\\phi_1 \\wedge \\phi_2) = v(\\phi_1)\\times v(\\phi_2)\\)<br>-&nbsp;\\(v(\\phi_1 \\vee \\phi_2) = v(\\phi_1) + v(\\phi_2) - v(\\phi_1)\\times v(\\phi_2) = \\max(v(\\phi_1), v(\\phi_2))\\)<br>-&nbsp;\\(v(\\phi_1\\to \\phi_2) = \\max(1-v(\\phi_1), \\phi_2)\\)<br>-&nbsp;\\(v(\\phi_1 \\leftrightarrow \\phi_2) = 1-(v(\\phi_1)+v(\\phi_2) \\mod 2)\\)"
            ],
            "guid": "D4eqo~T]LH",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "logique"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "conséquence logique",
                "si toute valuation v&nbsp;\\(v \\models \\phi\\)&nbsp;implique&nbsp;\\(v\\models \\psi\\)&nbsp;on le note parfois&nbsp;\\(\\phi \\models \\psi\\)"
            ],
            "guid": "cpji<m*3%(",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "logique"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "définition clause",
                "une disjonction de littéraux \\(\\bigvee_{i=1}^n{l_i}\\)"
            ],
            "guid": "L|d1FLUQ5e",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "logique"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "définition littéral",
                "formule réduite à une variable ou la négation d'une variable"
            ],
            "guid": "P.e2hS:9}B",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "logique"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Forme normale conjonctive",
                "conjonction de clauses"
            ],
            "guid": "MZqw*_g]sC",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "logique"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Forme normale Disjonctive",
                "Une disjonction de conjonction de littéraux"
            ],
            "guid": "M^j`VI>(r0",
            "note_model_uuid": "3ca50c8c-a9d6-11ef-974d-f92c0362d330",
            "tags": [
                "logique"
            ]
        }
    ],
    "reviewLimit": null,
    "reviewLimitToday": null
}